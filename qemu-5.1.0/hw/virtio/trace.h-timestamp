/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_VIRTIO_GENERATED_TRACERS_H
#define TRACE_HW_VIRTIO_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_VHOST_COMMIT_EVENT;
extern TraceEvent _TRACE_VHOST_REGION_ADD_SECTION_EVENT;
extern TraceEvent _TRACE_VHOST_REGION_ADD_SECTION_MERGE_EVENT;
extern TraceEvent _TRACE_VHOST_REGION_ADD_SECTION_ALIGNED_EVENT;
extern TraceEvent _TRACE_VHOST_SECTION_EVENT;
extern TraceEvent _TRACE_VHOST_REJECT_SECTION_EVENT;
extern TraceEvent _TRACE_VHOST_IOTLB_MISS_EVENT;
extern TraceEvent _TRACE_VHOST_USER_POSTCOPY_END_ENTRY_EVENT;
extern TraceEvent _TRACE_VHOST_USER_POSTCOPY_END_EXIT_EVENT;
extern TraceEvent _TRACE_VHOST_USER_POSTCOPY_FAULT_HANDLER_EVENT;
extern TraceEvent _TRACE_VHOST_USER_POSTCOPY_FAULT_HANDLER_LOOP_EVENT;
extern TraceEvent _TRACE_VHOST_USER_POSTCOPY_FAULT_HANDLER_FOUND_EVENT;
extern TraceEvent _TRACE_VHOST_USER_POSTCOPY_LISTEN_EVENT;
extern TraceEvent _TRACE_VHOST_USER_SET_MEM_TABLE_POSTCOPY_EVENT;
extern TraceEvent _TRACE_VHOST_USER_SET_MEM_TABLE_WITHFD_EVENT;
extern TraceEvent _TRACE_VHOST_USER_POSTCOPY_WAKER_EVENT;
extern TraceEvent _TRACE_VHOST_USER_POSTCOPY_WAKER_FOUND_EVENT;
extern TraceEvent _TRACE_VHOST_USER_POSTCOPY_WAKER_NOMATCH_EVENT;
extern TraceEvent _TRACE_VIRTQUEUE_ALLOC_ELEMENT_EVENT;
extern TraceEvent _TRACE_VIRTQUEUE_FILL_EVENT;
extern TraceEvent _TRACE_VIRTQUEUE_FLUSH_EVENT;
extern TraceEvent _TRACE_VIRTQUEUE_POP_EVENT;
extern TraceEvent _TRACE_VIRTIO_QUEUE_NOTIFY_EVENT;
extern TraceEvent _TRACE_VIRTIO_NOTIFY_IRQFD_EVENT;
extern TraceEvent _TRACE_VIRTIO_NOTIFY_EVENT;
extern TraceEvent _TRACE_VIRTIO_SET_STATUS_EVENT;
extern TraceEvent _TRACE_VIRTIO_RNG_GUEST_NOT_READY_EVENT;
extern TraceEvent _TRACE_VIRTIO_RNG_CPU_IS_STOPPED_EVENT;
extern TraceEvent _TRACE_VIRTIO_RNG_POPPED_EVENT;
extern TraceEvent _TRACE_VIRTIO_RNG_PUSHED_EVENT;
extern TraceEvent _TRACE_VIRTIO_RNG_REQUEST_EVENT;
extern TraceEvent _TRACE_VIRTIO_RNG_VM_STATE_CHANGE_EVENT;
extern TraceEvent _TRACE_VIRTIO_BALLOON_BAD_ADDR_EVENT;
extern TraceEvent _TRACE_VIRTIO_BALLOON_HANDLE_OUTPUT_EVENT;
extern TraceEvent _TRACE_VIRTIO_BALLOON_GET_CONFIG_EVENT;
extern TraceEvent _TRACE_VIRTIO_BALLOON_SET_CONFIG_EVENT;
extern TraceEvent _TRACE_VIRTIO_BALLOON_TO_TARGET_EVENT;
extern TraceEvent _TRACE_VIRTIO_MMIO_READ_EVENT;
extern TraceEvent _TRACE_VIRTIO_MMIO_WRITE_OFFSET_EVENT;
extern TraceEvent _TRACE_VIRTIO_MMIO_GUEST_PAGE_EVENT;
extern TraceEvent _TRACE_VIRTIO_MMIO_QUEUE_WRITE_EVENT;
extern TraceEvent _TRACE_VIRTIO_MMIO_SETTING_IRQ_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_DEVICE_RESET_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_GET_FEATURES_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_DEVICE_STATUS_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_GET_CONFIG_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_SET_CONFIG_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_ATTACH_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_DETACH_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_MAP_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_UNMAP_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_UNMAP_DONE_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_TRANSLATE_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_INIT_IOMMU_MR_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_GET_ENDPOINT_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_PUT_ENDPOINT_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_GET_DOMAIN_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_PUT_DOMAIN_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_TRANSLATE_OUT_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_REPORT_FAULT_EVENT;
extern TraceEvent _TRACE_VIRTIO_IOMMU_FILL_RESV_PROPERTY_EVENT;
extern TraceEvent _TRACE_VIRTIO_MEM_SEND_RESPONSE_EVENT;
extern TraceEvent _TRACE_VIRTIO_MEM_PLUG_REQUEST_EVENT;
extern TraceEvent _TRACE_VIRTIO_MEM_UNPLUG_REQUEST_EVENT;
extern TraceEvent _TRACE_VIRTIO_MEM_UNPLUGGED_ALL_EVENT;
extern TraceEvent _TRACE_VIRTIO_MEM_UNPLUG_ALL_REQUEST_EVENT;
extern TraceEvent _TRACE_VIRTIO_MEM_RESIZED_USABLE_REGION_EVENT;
extern TraceEvent _TRACE_VIRTIO_MEM_STATE_REQUEST_EVENT;
extern TraceEvent _TRACE_VIRTIO_MEM_STATE_RESPONSE_EVENT;
extern uint16_t _TRACE_VHOST_COMMIT_DSTATE;
extern uint16_t _TRACE_VHOST_REGION_ADD_SECTION_DSTATE;
extern uint16_t _TRACE_VHOST_REGION_ADD_SECTION_MERGE_DSTATE;
extern uint16_t _TRACE_VHOST_REGION_ADD_SECTION_ALIGNED_DSTATE;
extern uint16_t _TRACE_VHOST_SECTION_DSTATE;
extern uint16_t _TRACE_VHOST_REJECT_SECTION_DSTATE;
extern uint16_t _TRACE_VHOST_IOTLB_MISS_DSTATE;
extern uint16_t _TRACE_VHOST_USER_POSTCOPY_END_ENTRY_DSTATE;
extern uint16_t _TRACE_VHOST_USER_POSTCOPY_END_EXIT_DSTATE;
extern uint16_t _TRACE_VHOST_USER_POSTCOPY_FAULT_HANDLER_DSTATE;
extern uint16_t _TRACE_VHOST_USER_POSTCOPY_FAULT_HANDLER_LOOP_DSTATE;
extern uint16_t _TRACE_VHOST_USER_POSTCOPY_FAULT_HANDLER_FOUND_DSTATE;
extern uint16_t _TRACE_VHOST_USER_POSTCOPY_LISTEN_DSTATE;
extern uint16_t _TRACE_VHOST_USER_SET_MEM_TABLE_POSTCOPY_DSTATE;
extern uint16_t _TRACE_VHOST_USER_SET_MEM_TABLE_WITHFD_DSTATE;
extern uint16_t _TRACE_VHOST_USER_POSTCOPY_WAKER_DSTATE;
extern uint16_t _TRACE_VHOST_USER_POSTCOPY_WAKER_FOUND_DSTATE;
extern uint16_t _TRACE_VHOST_USER_POSTCOPY_WAKER_NOMATCH_DSTATE;
extern uint16_t _TRACE_VIRTQUEUE_ALLOC_ELEMENT_DSTATE;
extern uint16_t _TRACE_VIRTQUEUE_FILL_DSTATE;
extern uint16_t _TRACE_VIRTQUEUE_FLUSH_DSTATE;
extern uint16_t _TRACE_VIRTQUEUE_POP_DSTATE;
extern uint16_t _TRACE_VIRTIO_QUEUE_NOTIFY_DSTATE;
extern uint16_t _TRACE_VIRTIO_NOTIFY_IRQFD_DSTATE;
extern uint16_t _TRACE_VIRTIO_NOTIFY_DSTATE;
extern uint16_t _TRACE_VIRTIO_SET_STATUS_DSTATE;
extern uint16_t _TRACE_VIRTIO_RNG_GUEST_NOT_READY_DSTATE;
extern uint16_t _TRACE_VIRTIO_RNG_CPU_IS_STOPPED_DSTATE;
extern uint16_t _TRACE_VIRTIO_RNG_POPPED_DSTATE;
extern uint16_t _TRACE_VIRTIO_RNG_PUSHED_DSTATE;
extern uint16_t _TRACE_VIRTIO_RNG_REQUEST_DSTATE;
extern uint16_t _TRACE_VIRTIO_RNG_VM_STATE_CHANGE_DSTATE;
extern uint16_t _TRACE_VIRTIO_BALLOON_BAD_ADDR_DSTATE;
extern uint16_t _TRACE_VIRTIO_BALLOON_HANDLE_OUTPUT_DSTATE;
extern uint16_t _TRACE_VIRTIO_BALLOON_GET_CONFIG_DSTATE;
extern uint16_t _TRACE_VIRTIO_BALLOON_SET_CONFIG_DSTATE;
extern uint16_t _TRACE_VIRTIO_BALLOON_TO_TARGET_DSTATE;
extern uint16_t _TRACE_VIRTIO_MMIO_READ_DSTATE;
extern uint16_t _TRACE_VIRTIO_MMIO_WRITE_OFFSET_DSTATE;
extern uint16_t _TRACE_VIRTIO_MMIO_GUEST_PAGE_DSTATE;
extern uint16_t _TRACE_VIRTIO_MMIO_QUEUE_WRITE_DSTATE;
extern uint16_t _TRACE_VIRTIO_MMIO_SETTING_IRQ_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_DEVICE_RESET_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_GET_FEATURES_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_DEVICE_STATUS_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_GET_CONFIG_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_SET_CONFIG_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_ATTACH_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_DETACH_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_MAP_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_UNMAP_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_UNMAP_DONE_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_TRANSLATE_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_INIT_IOMMU_MR_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_GET_ENDPOINT_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_PUT_ENDPOINT_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_GET_DOMAIN_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_PUT_DOMAIN_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_TRANSLATE_OUT_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_REPORT_FAULT_DSTATE;
extern uint16_t _TRACE_VIRTIO_IOMMU_FILL_RESV_PROPERTY_DSTATE;
extern uint16_t _TRACE_VIRTIO_MEM_SEND_RESPONSE_DSTATE;
extern uint16_t _TRACE_VIRTIO_MEM_PLUG_REQUEST_DSTATE;
extern uint16_t _TRACE_VIRTIO_MEM_UNPLUG_REQUEST_DSTATE;
extern uint16_t _TRACE_VIRTIO_MEM_UNPLUGGED_ALL_DSTATE;
extern uint16_t _TRACE_VIRTIO_MEM_UNPLUG_ALL_REQUEST_DSTATE;
extern uint16_t _TRACE_VIRTIO_MEM_RESIZED_USABLE_REGION_DSTATE;
extern uint16_t _TRACE_VIRTIO_MEM_STATE_REQUEST_DSTATE;
extern uint16_t _TRACE_VIRTIO_MEM_STATE_RESPONSE_DSTATE;
#define TRACE_VHOST_COMMIT_ENABLED 1
#define TRACE_VHOST_REGION_ADD_SECTION_ENABLED 1
#define TRACE_VHOST_REGION_ADD_SECTION_MERGE_ENABLED 1
#define TRACE_VHOST_REGION_ADD_SECTION_ALIGNED_ENABLED 1
#define TRACE_VHOST_SECTION_ENABLED 1
#define TRACE_VHOST_REJECT_SECTION_ENABLED 1
#define TRACE_VHOST_IOTLB_MISS_ENABLED 1
#define TRACE_VHOST_USER_POSTCOPY_END_ENTRY_ENABLED 1
#define TRACE_VHOST_USER_POSTCOPY_END_EXIT_ENABLED 1
#define TRACE_VHOST_USER_POSTCOPY_FAULT_HANDLER_ENABLED 1
#define TRACE_VHOST_USER_POSTCOPY_FAULT_HANDLER_LOOP_ENABLED 1
#define TRACE_VHOST_USER_POSTCOPY_FAULT_HANDLER_FOUND_ENABLED 1
#define TRACE_VHOST_USER_POSTCOPY_LISTEN_ENABLED 1
#define TRACE_VHOST_USER_SET_MEM_TABLE_POSTCOPY_ENABLED 1
#define TRACE_VHOST_USER_SET_MEM_TABLE_WITHFD_ENABLED 1
#define TRACE_VHOST_USER_POSTCOPY_WAKER_ENABLED 1
#define TRACE_VHOST_USER_POSTCOPY_WAKER_FOUND_ENABLED 1
#define TRACE_VHOST_USER_POSTCOPY_WAKER_NOMATCH_ENABLED 1
#define TRACE_VIRTQUEUE_ALLOC_ELEMENT_ENABLED 1
#define TRACE_VIRTQUEUE_FILL_ENABLED 1
#define TRACE_VIRTQUEUE_FLUSH_ENABLED 1
#define TRACE_VIRTQUEUE_POP_ENABLED 1
#define TRACE_VIRTIO_QUEUE_NOTIFY_ENABLED 1
#define TRACE_VIRTIO_NOTIFY_IRQFD_ENABLED 1
#define TRACE_VIRTIO_NOTIFY_ENABLED 1
#define TRACE_VIRTIO_SET_STATUS_ENABLED 1
#define TRACE_VIRTIO_RNG_GUEST_NOT_READY_ENABLED 1
#define TRACE_VIRTIO_RNG_CPU_IS_STOPPED_ENABLED 1
#define TRACE_VIRTIO_RNG_POPPED_ENABLED 1
#define TRACE_VIRTIO_RNG_PUSHED_ENABLED 1
#define TRACE_VIRTIO_RNG_REQUEST_ENABLED 1
#define TRACE_VIRTIO_RNG_VM_STATE_CHANGE_ENABLED 1
#define TRACE_VIRTIO_BALLOON_BAD_ADDR_ENABLED 1
#define TRACE_VIRTIO_BALLOON_HANDLE_OUTPUT_ENABLED 1
#define TRACE_VIRTIO_BALLOON_GET_CONFIG_ENABLED 1
#define TRACE_VIRTIO_BALLOON_SET_CONFIG_ENABLED 1
#define TRACE_VIRTIO_BALLOON_TO_TARGET_ENABLED 1
#define TRACE_VIRTIO_MMIO_READ_ENABLED 1
#define TRACE_VIRTIO_MMIO_WRITE_OFFSET_ENABLED 1
#define TRACE_VIRTIO_MMIO_GUEST_PAGE_ENABLED 1
#define TRACE_VIRTIO_MMIO_QUEUE_WRITE_ENABLED 1
#define TRACE_VIRTIO_MMIO_SETTING_IRQ_ENABLED 1
#define TRACE_VIRTIO_IOMMU_DEVICE_RESET_ENABLED 1
#define TRACE_VIRTIO_IOMMU_GET_FEATURES_ENABLED 1
#define TRACE_VIRTIO_IOMMU_DEVICE_STATUS_ENABLED 1
#define TRACE_VIRTIO_IOMMU_GET_CONFIG_ENABLED 1
#define TRACE_VIRTIO_IOMMU_SET_CONFIG_ENABLED 1
#define TRACE_VIRTIO_IOMMU_ATTACH_ENABLED 1
#define TRACE_VIRTIO_IOMMU_DETACH_ENABLED 1
#define TRACE_VIRTIO_IOMMU_MAP_ENABLED 1
#define TRACE_VIRTIO_IOMMU_UNMAP_ENABLED 1
#define TRACE_VIRTIO_IOMMU_UNMAP_DONE_ENABLED 1
#define TRACE_VIRTIO_IOMMU_TRANSLATE_ENABLED 1
#define TRACE_VIRTIO_IOMMU_INIT_IOMMU_MR_ENABLED 1
#define TRACE_VIRTIO_IOMMU_GET_ENDPOINT_ENABLED 1
#define TRACE_VIRTIO_IOMMU_PUT_ENDPOINT_ENABLED 1
#define TRACE_VIRTIO_IOMMU_GET_DOMAIN_ENABLED 1
#define TRACE_VIRTIO_IOMMU_PUT_DOMAIN_ENABLED 1
#define TRACE_VIRTIO_IOMMU_TRANSLATE_OUT_ENABLED 1
#define TRACE_VIRTIO_IOMMU_REPORT_FAULT_ENABLED 1
#define TRACE_VIRTIO_IOMMU_FILL_RESV_PROPERTY_ENABLED 1
#define TRACE_VIRTIO_MEM_SEND_RESPONSE_ENABLED 1
#define TRACE_VIRTIO_MEM_PLUG_REQUEST_ENABLED 1
#define TRACE_VIRTIO_MEM_UNPLUG_REQUEST_ENABLED 1
#define TRACE_VIRTIO_MEM_UNPLUGGED_ALL_ENABLED 1
#define TRACE_VIRTIO_MEM_UNPLUG_ALL_REQUEST_ENABLED 1
#define TRACE_VIRTIO_MEM_RESIZED_USABLE_REGION_ENABLED 1
#define TRACE_VIRTIO_MEM_STATE_REQUEST_ENABLED 1
#define TRACE_VIRTIO_MEM_STATE_RESPONSE_ENABLED 1
#include "qemu/log-for-trace.h"


#define TRACE_VHOST_COMMIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_COMMIT) || \
    false)

static inline void _nocheck__trace_vhost_commit(bool started, bool changed)
{
    if (trace_event_get_state(TRACE_VHOST_COMMIT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vhost_commit " "Started: %d Changed: %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , started, changed);
    }
}

static inline void trace_vhost_commit(bool started, bool changed)
{
    if (true) {
        _nocheck__trace_vhost_commit(started, changed);
    }
}

#define TRACE_VHOST_REGION_ADD_SECTION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_REGION_ADD_SECTION) || \
    false)

static inline void _nocheck__trace_vhost_region_add_section(const char * name, uint64_t gpa, uint64_t size, uint64_t host)
{
    if (trace_event_get_state(TRACE_VHOST_REGION_ADD_SECTION) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vhost_region_add_section " "%s: 0x%"PRIx64"+0x%"PRIx64" @ 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , name, gpa, size, host);
    }
}

static inline void trace_vhost_region_add_section(const char * name, uint64_t gpa, uint64_t size, uint64_t host)
{
    if (true) {
        _nocheck__trace_vhost_region_add_section(name, gpa, size, host);
    }
}

#define TRACE_VHOST_REGION_ADD_SECTION_MERGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_REGION_ADD_SECTION_MERGE) || \
    false)

static inline void _nocheck__trace_vhost_region_add_section_merge(const char * name, uint64_t new_size, uint64_t gpa, uint64_t owr)
{
    if (trace_event_get_state(TRACE_VHOST_REGION_ADD_SECTION_MERGE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vhost_region_add_section_merge " "%s: size: 0x%"PRIx64 " gpa: 0x%"PRIx64 " owr: 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , name, new_size, gpa, owr);
    }
}

static inline void trace_vhost_region_add_section_merge(const char * name, uint64_t new_size, uint64_t gpa, uint64_t owr)
{
    if (true) {
        _nocheck__trace_vhost_region_add_section_merge(name, new_size, gpa, owr);
    }
}

#define TRACE_VHOST_REGION_ADD_SECTION_ALIGNED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_REGION_ADD_SECTION_ALIGNED) || \
    false)

static inline void _nocheck__trace_vhost_region_add_section_aligned(const char * name, uint64_t gpa, uint64_t size, uint64_t host)
{
    if (trace_event_get_state(TRACE_VHOST_REGION_ADD_SECTION_ALIGNED) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vhost_region_add_section_aligned " "%s: 0x%"PRIx64"+0x%"PRIx64" @ 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , name, gpa, size, host);
    }
}

static inline void trace_vhost_region_add_section_aligned(const char * name, uint64_t gpa, uint64_t size, uint64_t host)
{
    if (true) {
        _nocheck__trace_vhost_region_add_section_aligned(name, gpa, size, host);
    }
}

#define TRACE_VHOST_SECTION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_SECTION) || \
    false)

static inline void _nocheck__trace_vhost_section(const char * name)
{
    if (trace_event_get_state(TRACE_VHOST_SECTION) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vhost_section " "%s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , name);
    }
}

static inline void trace_vhost_section(const char * name)
{
    if (true) {
        _nocheck__trace_vhost_section(name);
    }
}

#define TRACE_VHOST_REJECT_SECTION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_REJECT_SECTION) || \
    false)

static inline void _nocheck__trace_vhost_reject_section(const char * name, int d)
{
    if (trace_event_get_state(TRACE_VHOST_REJECT_SECTION) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vhost_reject_section " "%s:%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , name, d);
    }
}

static inline void trace_vhost_reject_section(const char * name, int d)
{
    if (true) {
        _nocheck__trace_vhost_reject_section(name, d);
    }
}

#define TRACE_VHOST_IOTLB_MISS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_IOTLB_MISS) || \
    false)

static inline void _nocheck__trace_vhost_iotlb_miss(void * dev, int step)
{
    if (trace_event_get_state(TRACE_VHOST_IOTLB_MISS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vhost_iotlb_miss " "%p step %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , dev, step);
    }
}

static inline void trace_vhost_iotlb_miss(void * dev, int step)
{
    if (true) {
        _nocheck__trace_vhost_iotlb_miss(dev, step);
    }
}

#define TRACE_VHOST_USER_POSTCOPY_END_ENTRY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_USER_POSTCOPY_END_ENTRY) || \
    false)

static inline void _nocheck__trace_vhost_user_postcopy_end_entry(void)
{
    if (trace_event_get_state(TRACE_VHOST_USER_POSTCOPY_END_ENTRY) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vhost_user_postcopy_end_entry " "" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_vhost_user_postcopy_end_entry(void)
{
    if (true) {
        _nocheck__trace_vhost_user_postcopy_end_entry();
    }
}

#define TRACE_VHOST_USER_POSTCOPY_END_EXIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_USER_POSTCOPY_END_EXIT) || \
    false)

static inline void _nocheck__trace_vhost_user_postcopy_end_exit(void)
{
    if (trace_event_get_state(TRACE_VHOST_USER_POSTCOPY_END_EXIT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vhost_user_postcopy_end_exit " "" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_vhost_user_postcopy_end_exit(void)
{
    if (true) {
        _nocheck__trace_vhost_user_postcopy_end_exit();
    }
}

#define TRACE_VHOST_USER_POSTCOPY_FAULT_HANDLER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_USER_POSTCOPY_FAULT_HANDLER) || \
    false)

static inline void _nocheck__trace_vhost_user_postcopy_fault_handler(const char * name, uint64_t fault_address, int nregions)
{
    if (trace_event_get_state(TRACE_VHOST_USER_POSTCOPY_FAULT_HANDLER) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vhost_user_postcopy_fault_handler " "%s: @0x%"PRIx64" nregions:%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , name, fault_address, nregions);
    }
}

static inline void trace_vhost_user_postcopy_fault_handler(const char * name, uint64_t fault_address, int nregions)
{
    if (true) {
        _nocheck__trace_vhost_user_postcopy_fault_handler(name, fault_address, nregions);
    }
}

#define TRACE_VHOST_USER_POSTCOPY_FAULT_HANDLER_LOOP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_USER_POSTCOPY_FAULT_HANDLER_LOOP) || \
    false)

static inline void _nocheck__trace_vhost_user_postcopy_fault_handler_loop(int i, uint64_t client_base, uint64_t size)
{
    if (trace_event_get_state(TRACE_VHOST_USER_POSTCOPY_FAULT_HANDLER_LOOP) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vhost_user_postcopy_fault_handler_loop " "%d: client 0x%"PRIx64" +0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , i, client_base, size);
    }
}

static inline void trace_vhost_user_postcopy_fault_handler_loop(int i, uint64_t client_base, uint64_t size)
{
    if (true) {
        _nocheck__trace_vhost_user_postcopy_fault_handler_loop(i, client_base, size);
    }
}

#define TRACE_VHOST_USER_POSTCOPY_FAULT_HANDLER_FOUND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_USER_POSTCOPY_FAULT_HANDLER_FOUND) || \
    false)

static inline void _nocheck__trace_vhost_user_postcopy_fault_handler_found(int i, uint64_t region_offset, uint64_t rb_offset)
{
    if (trace_event_get_state(TRACE_VHOST_USER_POSTCOPY_FAULT_HANDLER_FOUND) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vhost_user_postcopy_fault_handler_found " "%d: region_offset: 0x%"PRIx64" rb_offset:0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , i, region_offset, rb_offset);
    }
}

static inline void trace_vhost_user_postcopy_fault_handler_found(int i, uint64_t region_offset, uint64_t rb_offset)
{
    if (true) {
        _nocheck__trace_vhost_user_postcopy_fault_handler_found(i, region_offset, rb_offset);
    }
}

#define TRACE_VHOST_USER_POSTCOPY_LISTEN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_USER_POSTCOPY_LISTEN) || \
    false)

static inline void _nocheck__trace_vhost_user_postcopy_listen(void)
{
    if (trace_event_get_state(TRACE_VHOST_USER_POSTCOPY_LISTEN) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vhost_user_postcopy_listen " "" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_vhost_user_postcopy_listen(void)
{
    if (true) {
        _nocheck__trace_vhost_user_postcopy_listen();
    }
}

#define TRACE_VHOST_USER_SET_MEM_TABLE_POSTCOPY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_USER_SET_MEM_TABLE_POSTCOPY) || \
    false)

static inline void _nocheck__trace_vhost_user_set_mem_table_postcopy(uint64_t client_addr, uint64_t qhva, int reply_i, int region_i)
{
    if (trace_event_get_state(TRACE_VHOST_USER_SET_MEM_TABLE_POSTCOPY) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vhost_user_set_mem_table_postcopy " "client:0x%"PRIx64" for hva: 0x%"PRIx64" reply %d region %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , client_addr, qhva, reply_i, region_i);
    }
}

static inline void trace_vhost_user_set_mem_table_postcopy(uint64_t client_addr, uint64_t qhva, int reply_i, int region_i)
{
    if (true) {
        _nocheck__trace_vhost_user_set_mem_table_postcopy(client_addr, qhva, reply_i, region_i);
    }
}

#define TRACE_VHOST_USER_SET_MEM_TABLE_WITHFD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_USER_SET_MEM_TABLE_WITHFD) || \
    false)

static inline void _nocheck__trace_vhost_user_set_mem_table_withfd(int index, const char * name, uint64_t memory_size, uint64_t guest_phys_addr, uint64_t userspace_addr, uint64_t offset)
{
    if (trace_event_get_state(TRACE_VHOST_USER_SET_MEM_TABLE_WITHFD) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vhost_user_set_mem_table_withfd " "%d:%s: size:0x%"PRIx64" GPA:0x%"PRIx64" QVA/userspace:0x%"PRIx64" RB offset:0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , index, name, memory_size, guest_phys_addr, userspace_addr, offset);
    }
}

static inline void trace_vhost_user_set_mem_table_withfd(int index, const char * name, uint64_t memory_size, uint64_t guest_phys_addr, uint64_t userspace_addr, uint64_t offset)
{
    if (true) {
        _nocheck__trace_vhost_user_set_mem_table_withfd(index, name, memory_size, guest_phys_addr, userspace_addr, offset);
    }
}

#define TRACE_VHOST_USER_POSTCOPY_WAKER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_USER_POSTCOPY_WAKER) || \
    false)

static inline void _nocheck__trace_vhost_user_postcopy_waker(const char * rb, uint64_t rb_offset)
{
    if (trace_event_get_state(TRACE_VHOST_USER_POSTCOPY_WAKER) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vhost_user_postcopy_waker " "%s + 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , rb, rb_offset);
    }
}

static inline void trace_vhost_user_postcopy_waker(const char * rb, uint64_t rb_offset)
{
    if (true) {
        _nocheck__trace_vhost_user_postcopy_waker(rb, rb_offset);
    }
}

#define TRACE_VHOST_USER_POSTCOPY_WAKER_FOUND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_USER_POSTCOPY_WAKER_FOUND) || \
    false)

static inline void _nocheck__trace_vhost_user_postcopy_waker_found(uint64_t client_addr)
{
    if (trace_event_get_state(TRACE_VHOST_USER_POSTCOPY_WAKER_FOUND) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vhost_user_postcopy_waker_found " "0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , client_addr);
    }
}

static inline void trace_vhost_user_postcopy_waker_found(uint64_t client_addr)
{
    if (true) {
        _nocheck__trace_vhost_user_postcopy_waker_found(client_addr);
    }
}

#define TRACE_VHOST_USER_POSTCOPY_WAKER_NOMATCH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VHOST_USER_POSTCOPY_WAKER_NOMATCH) || \
    false)

static inline void _nocheck__trace_vhost_user_postcopy_waker_nomatch(const char * rb, uint64_t rb_offset)
{
    if (trace_event_get_state(TRACE_VHOST_USER_POSTCOPY_WAKER_NOMATCH) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:vhost_user_postcopy_waker_nomatch " "%s + 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , rb, rb_offset);
    }
}

static inline void trace_vhost_user_postcopy_waker_nomatch(const char * rb, uint64_t rb_offset)
{
    if (true) {
        _nocheck__trace_vhost_user_postcopy_waker_nomatch(rb, rb_offset);
    }
}

#define TRACE_VIRTQUEUE_ALLOC_ELEMENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTQUEUE_ALLOC_ELEMENT) || \
    false)

static inline void _nocheck__trace_virtqueue_alloc_element(void * elem, size_t sz, unsigned in_num, unsigned out_num)
{
    if (trace_event_get_state(TRACE_VIRTQUEUE_ALLOC_ELEMENT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtqueue_alloc_element " "elem %p size %zd in_num %u out_num %u" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , elem, sz, in_num, out_num);
    }
}

static inline void trace_virtqueue_alloc_element(void * elem, size_t sz, unsigned in_num, unsigned out_num)
{
    if (true) {
        _nocheck__trace_virtqueue_alloc_element(elem, sz, in_num, out_num);
    }
}

#define TRACE_VIRTQUEUE_FILL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTQUEUE_FILL) || \
    false)

static inline void _nocheck__trace_virtqueue_fill(void * vq, const void * elem, unsigned int len, unsigned int idx)
{
    if (trace_event_get_state(TRACE_VIRTQUEUE_FILL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtqueue_fill " "vq %p elem %p len %u idx %u" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , vq, elem, len, idx);
    }
}

static inline void trace_virtqueue_fill(void * vq, const void * elem, unsigned int len, unsigned int idx)
{
    if (true) {
        _nocheck__trace_virtqueue_fill(vq, elem, len, idx);
    }
}

#define TRACE_VIRTQUEUE_FLUSH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTQUEUE_FLUSH) || \
    false)

static inline void _nocheck__trace_virtqueue_flush(void * vq, unsigned int count)
{
    if (trace_event_get_state(TRACE_VIRTQUEUE_FLUSH) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtqueue_flush " "vq %p count %u" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , vq, count);
    }
}

static inline void trace_virtqueue_flush(void * vq, unsigned int count)
{
    if (true) {
        _nocheck__trace_virtqueue_flush(vq, count);
    }
}

#define TRACE_VIRTQUEUE_POP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTQUEUE_POP) || \
    false)

static inline void _nocheck__trace_virtqueue_pop(void * vq, void * elem, unsigned int in_num, unsigned int out_num)
{
    if (trace_event_get_state(TRACE_VIRTQUEUE_POP) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtqueue_pop " "vq %p elem %p in_num %u out_num %u" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , vq, elem, in_num, out_num);
    }
}

static inline void trace_virtqueue_pop(void * vq, void * elem, unsigned int in_num, unsigned int out_num)
{
    if (true) {
        _nocheck__trace_virtqueue_pop(vq, elem, in_num, out_num);
    }
}

#define TRACE_VIRTIO_QUEUE_NOTIFY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_QUEUE_NOTIFY) || \
    false)

static inline void _nocheck__trace_virtio_queue_notify(void * vdev, int n, void * vq)
{
    if (trace_event_get_state(TRACE_VIRTIO_QUEUE_NOTIFY) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_queue_notify " "vdev %p n %d vq %p" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , vdev, n, vq);
    }
}

static inline void trace_virtio_queue_notify(void * vdev, int n, void * vq)
{
    if (true) {
        _nocheck__trace_virtio_queue_notify(vdev, n, vq);
    }
}

#define TRACE_VIRTIO_NOTIFY_IRQFD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_NOTIFY_IRQFD) || \
    false)

static inline void _nocheck__trace_virtio_notify_irqfd(void * vdev, void * vq)
{
    if (trace_event_get_state(TRACE_VIRTIO_NOTIFY_IRQFD) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_notify_irqfd " "vdev %p vq %p" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , vdev, vq);
    }
}

static inline void trace_virtio_notify_irqfd(void * vdev, void * vq)
{
    if (true) {
        _nocheck__trace_virtio_notify_irqfd(vdev, vq);
    }
}

#define TRACE_VIRTIO_NOTIFY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_NOTIFY) || \
    false)

static inline void _nocheck__trace_virtio_notify(void * vdev, void * vq)
{
    if (trace_event_get_state(TRACE_VIRTIO_NOTIFY) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_notify " "vdev %p vq %p" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , vdev, vq);
    }
}

static inline void trace_virtio_notify(void * vdev, void * vq)
{
    if (true) {
        _nocheck__trace_virtio_notify(vdev, vq);
    }
}

#define TRACE_VIRTIO_SET_STATUS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_SET_STATUS) || \
    false)

static inline void _nocheck__trace_virtio_set_status(void * vdev, uint8_t val)
{
    if (trace_event_get_state(TRACE_VIRTIO_SET_STATUS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_set_status " "vdev %p val %u" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , vdev, val);
    }
}

static inline void trace_virtio_set_status(void * vdev, uint8_t val)
{
    if (true) {
        _nocheck__trace_virtio_set_status(vdev, val);
    }
}

#define TRACE_VIRTIO_RNG_GUEST_NOT_READY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_RNG_GUEST_NOT_READY) || \
    false)

static inline void _nocheck__trace_virtio_rng_guest_not_ready(void * rng)
{
    if (trace_event_get_state(TRACE_VIRTIO_RNG_GUEST_NOT_READY) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_rng_guest_not_ready " "rng %p: guest not ready" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , rng);
    }
}

static inline void trace_virtio_rng_guest_not_ready(void * rng)
{
    if (true) {
        _nocheck__trace_virtio_rng_guest_not_ready(rng);
    }
}

#define TRACE_VIRTIO_RNG_CPU_IS_STOPPED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_RNG_CPU_IS_STOPPED) || \
    false)

static inline void _nocheck__trace_virtio_rng_cpu_is_stopped(void * rng, int size)
{
    if (trace_event_get_state(TRACE_VIRTIO_RNG_CPU_IS_STOPPED) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_rng_cpu_is_stopped " "rng %p: cpu is stopped, dropping %d bytes" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , rng, size);
    }
}

static inline void trace_virtio_rng_cpu_is_stopped(void * rng, int size)
{
    if (true) {
        _nocheck__trace_virtio_rng_cpu_is_stopped(rng, size);
    }
}

#define TRACE_VIRTIO_RNG_POPPED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_RNG_POPPED) || \
    false)

static inline void _nocheck__trace_virtio_rng_popped(void * rng)
{
    if (trace_event_get_state(TRACE_VIRTIO_RNG_POPPED) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_rng_popped " "rng %p: elem popped" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , rng);
    }
}

static inline void trace_virtio_rng_popped(void * rng)
{
    if (true) {
        _nocheck__trace_virtio_rng_popped(rng);
    }
}

#define TRACE_VIRTIO_RNG_PUSHED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_RNG_PUSHED) || \
    false)

static inline void _nocheck__trace_virtio_rng_pushed(void * rng, size_t len)
{
    if (trace_event_get_state(TRACE_VIRTIO_RNG_PUSHED) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_rng_pushed " "rng %p: %zd bytes pushed" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , rng, len);
    }
}

static inline void trace_virtio_rng_pushed(void * rng, size_t len)
{
    if (true) {
        _nocheck__trace_virtio_rng_pushed(rng, len);
    }
}

#define TRACE_VIRTIO_RNG_REQUEST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_RNG_REQUEST) || \
    false)

static inline void _nocheck__trace_virtio_rng_request(void * rng, size_t size, unsigned quota)
{
    if (trace_event_get_state(TRACE_VIRTIO_RNG_REQUEST) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_rng_request " "rng %p: %zd bytes requested, %u bytes quota left" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , rng, size, quota);
    }
}

static inline void trace_virtio_rng_request(void * rng, size_t size, unsigned quota)
{
    if (true) {
        _nocheck__trace_virtio_rng_request(rng, size, quota);
    }
}

#define TRACE_VIRTIO_RNG_VM_STATE_CHANGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_RNG_VM_STATE_CHANGE) || \
    false)

static inline void _nocheck__trace_virtio_rng_vm_state_change(void * rng, int running, int state)
{
    if (trace_event_get_state(TRACE_VIRTIO_RNG_VM_STATE_CHANGE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_rng_vm_state_change " "rng %p: state change to running %d state %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , rng, running, state);
    }
}

static inline void trace_virtio_rng_vm_state_change(void * rng, int running, int state)
{
    if (true) {
        _nocheck__trace_virtio_rng_vm_state_change(rng, running, state);
    }
}

#define TRACE_VIRTIO_BALLOON_BAD_ADDR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BALLOON_BAD_ADDR) || \
    false)

static inline void _nocheck__trace_virtio_balloon_bad_addr(uint64_t gpa)
{
    if (trace_event_get_state(TRACE_VIRTIO_BALLOON_BAD_ADDR) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_balloon_bad_addr " "0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , gpa);
    }
}

static inline void trace_virtio_balloon_bad_addr(uint64_t gpa)
{
    if (true) {
        _nocheck__trace_virtio_balloon_bad_addr(gpa);
    }
}

#define TRACE_VIRTIO_BALLOON_HANDLE_OUTPUT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BALLOON_HANDLE_OUTPUT) || \
    false)

static inline void _nocheck__trace_virtio_balloon_handle_output(const char * name, uint64_t gpa)
{
    if (trace_event_get_state(TRACE_VIRTIO_BALLOON_HANDLE_OUTPUT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_balloon_handle_output " "section name: %s gpa: 0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , name, gpa);
    }
}

static inline void trace_virtio_balloon_handle_output(const char * name, uint64_t gpa)
{
    if (true) {
        _nocheck__trace_virtio_balloon_handle_output(name, gpa);
    }
}

#define TRACE_VIRTIO_BALLOON_GET_CONFIG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BALLOON_GET_CONFIG) || \
    false)

static inline void _nocheck__trace_virtio_balloon_get_config(uint32_t num_pages, uint32_t actual)
{
    if (trace_event_get_state(TRACE_VIRTIO_BALLOON_GET_CONFIG) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_balloon_get_config " "num_pages: %d actual: %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , num_pages, actual);
    }
}

static inline void trace_virtio_balloon_get_config(uint32_t num_pages, uint32_t actual)
{
    if (true) {
        _nocheck__trace_virtio_balloon_get_config(num_pages, actual);
    }
}

#define TRACE_VIRTIO_BALLOON_SET_CONFIG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BALLOON_SET_CONFIG) || \
    false)

static inline void _nocheck__trace_virtio_balloon_set_config(uint32_t actual, uint32_t oldactual)
{
    if (trace_event_get_state(TRACE_VIRTIO_BALLOON_SET_CONFIG) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_balloon_set_config " "actual: %d oldactual: %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , actual, oldactual);
    }
}

static inline void trace_virtio_balloon_set_config(uint32_t actual, uint32_t oldactual)
{
    if (true) {
        _nocheck__trace_virtio_balloon_set_config(actual, oldactual);
    }
}

#define TRACE_VIRTIO_BALLOON_TO_TARGET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BALLOON_TO_TARGET) || \
    false)

static inline void _nocheck__trace_virtio_balloon_to_target(uint64_t target, uint32_t num_pages)
{
    if (trace_event_get_state(TRACE_VIRTIO_BALLOON_TO_TARGET) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_balloon_to_target " "balloon target: 0x%"PRIx64" num_pages: %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , target, num_pages);
    }
}

static inline void trace_virtio_balloon_to_target(uint64_t target, uint32_t num_pages)
{
    if (true) {
        _nocheck__trace_virtio_balloon_to_target(target, num_pages);
    }
}

#define TRACE_VIRTIO_MMIO_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_MMIO_READ) || \
    false)

static inline void _nocheck__trace_virtio_mmio_read(uint64_t offset)
{
    if (trace_event_get_state(TRACE_VIRTIO_MMIO_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_mmio_read " "virtio_mmio_read offset 0x%" PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , offset);
    }
}

static inline void trace_virtio_mmio_read(uint64_t offset)
{
    if (true) {
        _nocheck__trace_virtio_mmio_read(offset);
    }
}

#define TRACE_VIRTIO_MMIO_WRITE_OFFSET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_MMIO_WRITE_OFFSET) || \
    false)

static inline void _nocheck__trace_virtio_mmio_write_offset(uint64_t offset, uint64_t value)
{
    if (trace_event_get_state(TRACE_VIRTIO_MMIO_WRITE_OFFSET) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_mmio_write_offset " "virtio_mmio_write offset 0x%" PRIx64 " value 0x%" PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , offset, value);
    }
}

static inline void trace_virtio_mmio_write_offset(uint64_t offset, uint64_t value)
{
    if (true) {
        _nocheck__trace_virtio_mmio_write_offset(offset, value);
    }
}

#define TRACE_VIRTIO_MMIO_GUEST_PAGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_MMIO_GUEST_PAGE) || \
    false)

static inline void _nocheck__trace_virtio_mmio_guest_page(uint64_t size, int shift)
{
    if (trace_event_get_state(TRACE_VIRTIO_MMIO_GUEST_PAGE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_mmio_guest_page " "guest page size 0x%" PRIx64 " shift %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , size, shift);
    }
}

static inline void trace_virtio_mmio_guest_page(uint64_t size, int shift)
{
    if (true) {
        _nocheck__trace_virtio_mmio_guest_page(size, shift);
    }
}

#define TRACE_VIRTIO_MMIO_QUEUE_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_MMIO_QUEUE_WRITE) || \
    false)

static inline void _nocheck__trace_virtio_mmio_queue_write(uint64_t value, int max_size)
{
    if (trace_event_get_state(TRACE_VIRTIO_MMIO_QUEUE_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_mmio_queue_write " "mmio_queue write 0x%" PRIx64 " max %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , value, max_size);
    }
}

static inline void trace_virtio_mmio_queue_write(uint64_t value, int max_size)
{
    if (true) {
        _nocheck__trace_virtio_mmio_queue_write(value, max_size);
    }
}

#define TRACE_VIRTIO_MMIO_SETTING_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_MMIO_SETTING_IRQ) || \
    false)

static inline void _nocheck__trace_virtio_mmio_setting_irq(int level)
{
    if (trace_event_get_state(TRACE_VIRTIO_MMIO_SETTING_IRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_mmio_setting_irq " "virtio_mmio setting IRQ %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , level);
    }
}

static inline void trace_virtio_mmio_setting_irq(int level)
{
    if (true) {
        _nocheck__trace_virtio_mmio_setting_irq(level);
    }
}

#define TRACE_VIRTIO_IOMMU_DEVICE_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_DEVICE_RESET) || \
    false)

static inline void _nocheck__trace_virtio_iommu_device_reset(void)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_DEVICE_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_iommu_device_reset " "reset!" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_virtio_iommu_device_reset(void)
{
    if (true) {
        _nocheck__trace_virtio_iommu_device_reset();
    }
}

#define TRACE_VIRTIO_IOMMU_GET_FEATURES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_GET_FEATURES) || \
    false)

static inline void _nocheck__trace_virtio_iommu_get_features(uint64_t features)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_GET_FEATURES) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_iommu_get_features " "device supports features=0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , features);
    }
}

static inline void trace_virtio_iommu_get_features(uint64_t features)
{
    if (true) {
        _nocheck__trace_virtio_iommu_get_features(features);
    }
}

#define TRACE_VIRTIO_IOMMU_DEVICE_STATUS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_DEVICE_STATUS) || \
    false)

static inline void _nocheck__trace_virtio_iommu_device_status(uint8_t status)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_DEVICE_STATUS) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_iommu_device_status " "driver status = %d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , status);
    }
}

static inline void trace_virtio_iommu_device_status(uint8_t status)
{
    if (true) {
        _nocheck__trace_virtio_iommu_device_status(status);
    }
}

#define TRACE_VIRTIO_IOMMU_GET_CONFIG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_GET_CONFIG) || \
    false)

static inline void _nocheck__trace_virtio_iommu_get_config(uint64_t page_size_mask, uint64_t start, uint64_t end, uint32_t domain_range, uint32_t probe_size)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_GET_CONFIG) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_iommu_get_config " "page_size_mask=0x%"PRIx64" start=0x%"PRIx64" end=0x%"PRIx64" domain_range=%d probe_size=0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , page_size_mask, start, end, domain_range, probe_size);
    }
}

static inline void trace_virtio_iommu_get_config(uint64_t page_size_mask, uint64_t start, uint64_t end, uint32_t domain_range, uint32_t probe_size)
{
    if (true) {
        _nocheck__trace_virtio_iommu_get_config(page_size_mask, start, end, domain_range, probe_size);
    }
}

#define TRACE_VIRTIO_IOMMU_SET_CONFIG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_SET_CONFIG) || \
    false)

static inline void _nocheck__trace_virtio_iommu_set_config(uint64_t page_size_mask, uint64_t start, uint64_t end, uint32_t domain_range, uint32_t probe_size)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_SET_CONFIG) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_iommu_set_config " "page_size_mask=0x%"PRIx64" start=0x%"PRIx64" end=0x%"PRIx64" domain_bits=%d probe_size=0x%x" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , page_size_mask, start, end, domain_range, probe_size);
    }
}

static inline void trace_virtio_iommu_set_config(uint64_t page_size_mask, uint64_t start, uint64_t end, uint32_t domain_range, uint32_t probe_size)
{
    if (true) {
        _nocheck__trace_virtio_iommu_set_config(page_size_mask, start, end, domain_range, probe_size);
    }
}

#define TRACE_VIRTIO_IOMMU_ATTACH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_ATTACH) || \
    false)

static inline void _nocheck__trace_virtio_iommu_attach(uint32_t domain_id, uint32_t ep_id)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_ATTACH) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_iommu_attach " "domain=%d endpoint=%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , domain_id, ep_id);
    }
}

static inline void trace_virtio_iommu_attach(uint32_t domain_id, uint32_t ep_id)
{
    if (true) {
        _nocheck__trace_virtio_iommu_attach(domain_id, ep_id);
    }
}

#define TRACE_VIRTIO_IOMMU_DETACH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_DETACH) || \
    false)

static inline void _nocheck__trace_virtio_iommu_detach(uint32_t domain_id, uint32_t ep_id)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_DETACH) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_iommu_detach " "domain=%d endpoint=%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , domain_id, ep_id);
    }
}

static inline void trace_virtio_iommu_detach(uint32_t domain_id, uint32_t ep_id)
{
    if (true) {
        _nocheck__trace_virtio_iommu_detach(domain_id, ep_id);
    }
}

#define TRACE_VIRTIO_IOMMU_MAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_MAP) || \
    false)

static inline void _nocheck__trace_virtio_iommu_map(uint32_t domain_id, uint64_t virt_start, uint64_t virt_end, uint64_t phys_start, uint32_t flags)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_MAP) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_iommu_map " "domain=%d virt_start=0x%"PRIx64" virt_end=0x%"PRIx64 " phys_start=0x%"PRIx64" flags=%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , domain_id, virt_start, virt_end, phys_start, flags);
    }
}

static inline void trace_virtio_iommu_map(uint32_t domain_id, uint64_t virt_start, uint64_t virt_end, uint64_t phys_start, uint32_t flags)
{
    if (true) {
        _nocheck__trace_virtio_iommu_map(domain_id, virt_start, virt_end, phys_start, flags);
    }
}

#define TRACE_VIRTIO_IOMMU_UNMAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_UNMAP) || \
    false)

static inline void _nocheck__trace_virtio_iommu_unmap(uint32_t domain_id, uint64_t virt_start, uint64_t virt_end)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_UNMAP) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_iommu_unmap " "domain=%d virt_start=0x%"PRIx64" virt_end=0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , domain_id, virt_start, virt_end);
    }
}

static inline void trace_virtio_iommu_unmap(uint32_t domain_id, uint64_t virt_start, uint64_t virt_end)
{
    if (true) {
        _nocheck__trace_virtio_iommu_unmap(domain_id, virt_start, virt_end);
    }
}

#define TRACE_VIRTIO_IOMMU_UNMAP_DONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_UNMAP_DONE) || \
    false)

static inline void _nocheck__trace_virtio_iommu_unmap_done(uint32_t domain_id, uint64_t virt_start, uint64_t virt_end)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_UNMAP_DONE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_iommu_unmap_done " "domain=%d virt_start=0x%"PRIx64" virt_end=0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , domain_id, virt_start, virt_end);
    }
}

static inline void trace_virtio_iommu_unmap_done(uint32_t domain_id, uint64_t virt_start, uint64_t virt_end)
{
    if (true) {
        _nocheck__trace_virtio_iommu_unmap_done(domain_id, virt_start, virt_end);
    }
}

#define TRACE_VIRTIO_IOMMU_TRANSLATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_TRANSLATE) || \
    false)

static inline void _nocheck__trace_virtio_iommu_translate(const char * name, uint32_t rid, uint64_t iova, int flag)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_TRANSLATE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_iommu_translate " "mr=%s rid=%d addr=0x%"PRIx64" flag=%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , name, rid, iova, flag);
    }
}

static inline void trace_virtio_iommu_translate(const char * name, uint32_t rid, uint64_t iova, int flag)
{
    if (true) {
        _nocheck__trace_virtio_iommu_translate(name, rid, iova, flag);
    }
}

#define TRACE_VIRTIO_IOMMU_INIT_IOMMU_MR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_INIT_IOMMU_MR) || \
    false)

static inline void _nocheck__trace_virtio_iommu_init_iommu_mr(char * iommu_mr)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_INIT_IOMMU_MR) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_iommu_init_iommu_mr " "init %s" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , iommu_mr);
    }
}

static inline void trace_virtio_iommu_init_iommu_mr(char * iommu_mr)
{
    if (true) {
        _nocheck__trace_virtio_iommu_init_iommu_mr(iommu_mr);
    }
}

#define TRACE_VIRTIO_IOMMU_GET_ENDPOINT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_GET_ENDPOINT) || \
    false)

static inline void _nocheck__trace_virtio_iommu_get_endpoint(uint32_t ep_id)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_GET_ENDPOINT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_iommu_get_endpoint " "Alloc endpoint=%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , ep_id);
    }
}

static inline void trace_virtio_iommu_get_endpoint(uint32_t ep_id)
{
    if (true) {
        _nocheck__trace_virtio_iommu_get_endpoint(ep_id);
    }
}

#define TRACE_VIRTIO_IOMMU_PUT_ENDPOINT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_PUT_ENDPOINT) || \
    false)

static inline void _nocheck__trace_virtio_iommu_put_endpoint(uint32_t ep_id)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_PUT_ENDPOINT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_iommu_put_endpoint " "Free endpoint=%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , ep_id);
    }
}

static inline void trace_virtio_iommu_put_endpoint(uint32_t ep_id)
{
    if (true) {
        _nocheck__trace_virtio_iommu_put_endpoint(ep_id);
    }
}

#define TRACE_VIRTIO_IOMMU_GET_DOMAIN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_GET_DOMAIN) || \
    false)

static inline void _nocheck__trace_virtio_iommu_get_domain(uint32_t domain_id)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_GET_DOMAIN) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_iommu_get_domain " "Alloc domain=%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , domain_id);
    }
}

static inline void trace_virtio_iommu_get_domain(uint32_t domain_id)
{
    if (true) {
        _nocheck__trace_virtio_iommu_get_domain(domain_id);
    }
}

#define TRACE_VIRTIO_IOMMU_PUT_DOMAIN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_PUT_DOMAIN) || \
    false)

static inline void _nocheck__trace_virtio_iommu_put_domain(uint32_t domain_id)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_PUT_DOMAIN) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_iommu_put_domain " "Free domain=%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , domain_id);
    }
}

static inline void trace_virtio_iommu_put_domain(uint32_t domain_id)
{
    if (true) {
        _nocheck__trace_virtio_iommu_put_domain(domain_id);
    }
}

#define TRACE_VIRTIO_IOMMU_TRANSLATE_OUT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_TRANSLATE_OUT) || \
    false)

static inline void _nocheck__trace_virtio_iommu_translate_out(uint64_t virt_addr, uint64_t phys_addr, uint32_t sid)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_TRANSLATE_OUT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_iommu_translate_out " "0x%"PRIx64" -> 0x%"PRIx64 " for sid=%d" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , virt_addr, phys_addr, sid);
    }
}

static inline void trace_virtio_iommu_translate_out(uint64_t virt_addr, uint64_t phys_addr, uint32_t sid)
{
    if (true) {
        _nocheck__trace_virtio_iommu_translate_out(virt_addr, phys_addr, sid);
    }
}

#define TRACE_VIRTIO_IOMMU_REPORT_FAULT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_REPORT_FAULT) || \
    false)

static inline void _nocheck__trace_virtio_iommu_report_fault(uint8_t reason, uint32_t flags, uint32_t endpoint, uint64_t addr)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_REPORT_FAULT) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_iommu_report_fault " "FAULT reason=%d flags=%d endpoint=%d address =0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , reason, flags, endpoint, addr);
    }
}

static inline void trace_virtio_iommu_report_fault(uint8_t reason, uint32_t flags, uint32_t endpoint, uint64_t addr)
{
    if (true) {
        _nocheck__trace_virtio_iommu_report_fault(reason, flags, endpoint, addr);
    }
}

#define TRACE_VIRTIO_IOMMU_FILL_RESV_PROPERTY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_IOMMU_FILL_RESV_PROPERTY) || \
    false)

static inline void _nocheck__trace_virtio_iommu_fill_resv_property(uint32_t devid, uint8_t subtype, uint64_t start, uint64_t end)
{
    if (trace_event_get_state(TRACE_VIRTIO_IOMMU_FILL_RESV_PROPERTY) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_iommu_fill_resv_property " "dev= %d, type=%d start=0x%"PRIx64" end=0x%"PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , devid, subtype, start, end);
    }
}

static inline void trace_virtio_iommu_fill_resv_property(uint32_t devid, uint8_t subtype, uint64_t start, uint64_t end)
{
    if (true) {
        _nocheck__trace_virtio_iommu_fill_resv_property(devid, subtype, start, end);
    }
}

#define TRACE_VIRTIO_MEM_SEND_RESPONSE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_MEM_SEND_RESPONSE) || \
    false)

static inline void _nocheck__trace_virtio_mem_send_response(uint16_t type)
{
    if (trace_event_get_state(TRACE_VIRTIO_MEM_SEND_RESPONSE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_mem_send_response " "type=%" PRIu16 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , type);
    }
}

static inline void trace_virtio_mem_send_response(uint16_t type)
{
    if (true) {
        _nocheck__trace_virtio_mem_send_response(type);
    }
}

#define TRACE_VIRTIO_MEM_PLUG_REQUEST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_MEM_PLUG_REQUEST) || \
    false)

static inline void _nocheck__trace_virtio_mem_plug_request(uint64_t addr, uint16_t nb_blocks)
{
    if (trace_event_get_state(TRACE_VIRTIO_MEM_PLUG_REQUEST) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_mem_plug_request " "addr=0x%" PRIx64 " nb_blocks=%" PRIu16 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, nb_blocks);
    }
}

static inline void trace_virtio_mem_plug_request(uint64_t addr, uint16_t nb_blocks)
{
    if (true) {
        _nocheck__trace_virtio_mem_plug_request(addr, nb_blocks);
    }
}

#define TRACE_VIRTIO_MEM_UNPLUG_REQUEST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_MEM_UNPLUG_REQUEST) || \
    false)

static inline void _nocheck__trace_virtio_mem_unplug_request(uint64_t addr, uint16_t nb_blocks)
{
    if (trace_event_get_state(TRACE_VIRTIO_MEM_UNPLUG_REQUEST) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_mem_unplug_request " "addr=0x%" PRIx64 " nb_blocks=%" PRIu16 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, nb_blocks);
    }
}

static inline void trace_virtio_mem_unplug_request(uint64_t addr, uint16_t nb_blocks)
{
    if (true) {
        _nocheck__trace_virtio_mem_unplug_request(addr, nb_blocks);
    }
}

#define TRACE_VIRTIO_MEM_UNPLUGGED_ALL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_MEM_UNPLUGGED_ALL) || \
    false)

static inline void _nocheck__trace_virtio_mem_unplugged_all(void)
{
    if (trace_event_get_state(TRACE_VIRTIO_MEM_UNPLUGGED_ALL) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_mem_unplugged_all " "" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_virtio_mem_unplugged_all(void)
{
    if (true) {
        _nocheck__trace_virtio_mem_unplugged_all();
    }
}

#define TRACE_VIRTIO_MEM_UNPLUG_ALL_REQUEST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_MEM_UNPLUG_ALL_REQUEST) || \
    false)

static inline void _nocheck__trace_virtio_mem_unplug_all_request(void)
{
    if (trace_event_get_state(TRACE_VIRTIO_MEM_UNPLUG_ALL_REQUEST) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_mem_unplug_all_request " "" "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 );
    }
}

static inline void trace_virtio_mem_unplug_all_request(void)
{
    if (true) {
        _nocheck__trace_virtio_mem_unplug_all_request();
    }
}

#define TRACE_VIRTIO_MEM_RESIZED_USABLE_REGION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_MEM_RESIZED_USABLE_REGION) || \
    false)

static inline void _nocheck__trace_virtio_mem_resized_usable_region(uint64_t old_size, uint64_t new_size)
{
    if (trace_event_get_state(TRACE_VIRTIO_MEM_RESIZED_USABLE_REGION) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_mem_resized_usable_region " "old_size=0x%" PRIx64 "new_size=0x%" PRIx64 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , old_size, new_size);
    }
}

static inline void trace_virtio_mem_resized_usable_region(uint64_t old_size, uint64_t new_size)
{
    if (true) {
        _nocheck__trace_virtio_mem_resized_usable_region(old_size, new_size);
    }
}

#define TRACE_VIRTIO_MEM_STATE_REQUEST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_MEM_STATE_REQUEST) || \
    false)

static inline void _nocheck__trace_virtio_mem_state_request(uint64_t addr, uint16_t nb_blocks)
{
    if (trace_event_get_state(TRACE_VIRTIO_MEM_STATE_REQUEST) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_mem_state_request " "addr=0x%" PRIx64 " nb_blocks=%" PRIu16 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , addr, nb_blocks);
    }
}

static inline void trace_virtio_mem_state_request(uint64_t addr, uint16_t nb_blocks)
{
    if (true) {
        _nocheck__trace_virtio_mem_state_request(addr, nb_blocks);
    }
}

#define TRACE_VIRTIO_MEM_STATE_RESPONSE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_MEM_STATE_RESPONSE) || \
    false)

static inline void _nocheck__trace_virtio_mem_state_response(uint16_t state)
{
    if (trace_event_get_state(TRACE_VIRTIO_MEM_STATE_RESPONSE) && qemu_loglevel_mask(LOG_TRACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log("%d@%zu.%06zu:virtio_mem_state_response " "state=%" PRIu16 "\n",
                 qemu_get_thread_id(),
                 (size_t)_now.tv_sec, (size_t)_now.tv_usec
                 , state);
    }
}

static inline void trace_virtio_mem_state_response(uint16_t state)
{
    if (true) {
        _nocheck__trace_virtio_mem_state_response(state);
    }
}
#endif /* TRACE_HW_VIRTIO_GENERATED_TRACERS_H */
